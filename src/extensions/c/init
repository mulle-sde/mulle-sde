#! /usr/bin/env bash
#
#   Copyright (c) 2017 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#

MULLE_C_DEVELOPER_VERSION=0.0.1

# allow these to be set via environment
#
VERSION="${VERSION:-${MULLE_C_DEVELOPER_VERSION}}"
PUBLISHER="${PUBLISHER:-mulle-sde}"
PUBLISHER_LOGO="mulle-c-developer.txt}"


usage()
{
   cat <<EOF >&2
Usage:
   ${MULLE_EXECUTABLE} [flags] <command> [options] [directory]

   Create a cmake based c project. It can be either a library or an
   executable.

Commands:
   check      : check current project
   executable : create a executable project
   empty      : do not create  project files
   library    : create a library project
   version    : print ${MULLE_EXECUTABLE} version

Options:
   -d <dir>   : use "dir" instead of working directory
   -n <name>  : give project a name

EOF
   exit 1
}


emit_readme_md()
{
   log_entry "emit_readme_md" "$@"

   cat <<EOF
# ${PROJECT_NAME}

This is a [mulle-sde](https://mulle-sde.github.io/) project.


You may need to use **[mulle-env](//github.com/mulle-sde/mulle-env)** to
build the project properly:

\`\`\`
mulle-env
\`\`\`
EOF

   echo "${ADDITIONAL_README}"
}


emit_cmakelists_common_header()
{
   log_entry "emit_cmakelists_common_header" "$@"

   cat <<EOF
cmake_minimum_required( VERSION 3.0)

project( ${PROJECT_NAME} C)

EOF
}


emit_cmakelists_common_footer()
{
   log_entry "emit_cmakelists_common_footer" "$@"

   :
}


emit_include_directories()
{
   log_entry "emit_include_directories" "$@"

   local nicey

   nicey="`sed 's|/$||' <<< "${FILE_PREFIX}"`"
   if [ ! -z "${nicey}" ]
   then
      cat <<EOF
include_directories(
${nicey}
)

EOF
   fi
}


emit_dependencies_library()
{
   log_entry "emit_dependencies_library" "$@"

   cat <<EOF
if( NOT __${PROJECT_UPCASE_IDENTIFIER}_CMAKE_DEPENDENCIES_TXT__)
   set( __${PROJECT_UPCASE_IDENTIFIER}_CMAKE_DEPENDENCIES_TXT__ ON)

   message( STATUS "# Include \"${PROJECT_NAME}\" CMakeDependencies.txt")

   #
   # Put your find_library() statements here to import other libraries
   #
   # Add OS specific dependencies to OS_SPECIFIC_LIBRARIES
   # Add all other dependencies (rest) to C_DEPENDENCIES_LIBRARIES

   #
   # mulle-sde may rewrite statements here (but usually not)
   # === MULLE-SDE START ===

   if( EXISTS _CMakeDependencies.txt)
      include( _CMakeDependencies.txt)
   endif()

   # === MULLE-SDE END ===
   #
   #

   # For the benefit of users of your library, provide the find_library
   # statement to find your library and add it to C_DEPENDENCY_LIBRARIES and
   # C_DEPENDENCY_NAMES
   #
   if( NOT ${PROJECT_UPCASE_IDENTIFIER}_LIBRARY)
      find_library( ${PROJECT_UPCASE_IDENTIFIER}_LIBRARY NAMES ${PROJECT_NAME})
      message(STATUS "${PROJECT_UPCASE_IDENTIFIER}_LIBRARY is \${${PROJECT_UPCASE_IDENTIFIER}_LIBRARY}")
      set( C_DEPENDENCY_LIBRARIES
         \${${PROJECT_UPCASE_IDENTIFIER}_LIBRARY}
         \${C_DEPENDENCY_LIBRARIES}
         CACHE INTERNAL "need to cache this"
      )
      set( C_DEPENDENCY_NAMES
         ${PROJECT_NAME}
         \${C_DEPENDENCY_NAMES}
         CACHE INTERNAL "need to cache this too"
      )
   endif()

   #
   # For benefit of Windows
   #
   if( MSVC)
      set( ${PROJECT_UPCASE_IDENTIFIER}_DEFINITIONS \${${UPCASE_MULLE_C_LIBRARY_IDENTIFIER}_DEFINITIONS})
   endif()
endif()
EOF
}


emit_sources_and_headers_library()
{
   log_entry "emit_sources_and_headers_library" "$@"

   if [ ! -z "${FILE_PREFIX}" ]
   then
      cat <<EOF
set( INCLUDE_DIRS
"${FILE_PREFIX}"
)
EOF
   fi

   cat <<EOF
set( SOURCES
"${FILE_PREFIX}Foo.c"
)

set( PUBLIC_HEADERS
"${FILE_PREFIX}Foo.h"
"${FILE_PREFIX}version.h"
)
EOF

   emit_include_directories
}


#
# TODO: move this to mulle-configuration.
#

emit_cmakelists_library()
{
   log_entry "emit_cmakelists_library" "$@"

   cat <<EOF

###

set( ${PROJECT_UPCASE_IDENTIFIER}_LIBRARY ON)
include( CMakeDependencies.txt)
include( CMakeSourcesAndHeaders.txt)

###

include_directories( ${INCLUDE_DIRS})


set( PUBLIC_HEADERS
\${PUBLIC_HEADERS}
"CMakeDependencies.txt"
"_CMakeDependencies.txt"
)


add_library( "${PROJECT_NAME}"
\${SOURCES}
\${PUBLIC_HEADERS}
\${PRIVATE_HEADERS}
CMakeLists.txt
CMakeSourcesAndHeaders.txt
)

set( STANDALONE_BASE_NAME "${PROJECT_NAME}")
set( STANDALONE_NAME "${PROJECT_NAME}Standalone")
set( STANDALONE_SOURCES "src/${PROJECT_NAME}Standalone.c")
set( STANDALONE_DEFINITIONS \${${PROJECT_UPCASE_IDENTIFIER}_DEFINITIONS})
set( STANDALONE_ALL_LOAD_LIBRARIES
    \$<TARGET_FILE:\${STANDALONE_BASE_NAME}>
    \${C_DEPENDENCY_LIBRARIES}
    \${C_STARTUP_LIBRARY}
    \${C_DEPENDENCY_LIBRARIES}
)

include( Standalone)

install( TARGETS "${PROJECT_NAME}" "${PROJECT_NAME}Standalone" DESTINATION "lib")
install( FILES \${PUBLIC_HEADERS}  DESTINATION "include/${PROJECT_NAME}")
install( FILES \${PRIVATE_HEADERS} DESTINATION "include/${PROJECT_NAME}/private")
EOF
}


emit_sources_and_headers_executable()
{
   log_entry "emit_sources_and_headers_executable" "$@"

   emit_include_directories

   cat <<EOF
set( SOURCES
"${FILE_PREFIX}Foo.c"
"${FILE_PREFIX}main.c"
)

set( PROJECT_HEADERS
"${FILE_PREFIX}Foo.h"
"${FILE_PREFIX}version.h"
)
EOF
}


emit_cmakelists_executable()
{
   log_entry "emit_cmakelists_executable" "$@"

   cat <<EOF

###

include( CMakeSourcesAndHeaders.txt)

###

add_executable( "${PROJECT_NAME}"
\${SOURCES}
\${PUBLIC_HEADERS}
\${PRIVATE_HEADERS}
CMakeLists.txt
CMakeSourcesAndHeaders.txt
)

###
EOF

   if [ "${OPTION_DYNAMIC_LINKED}" = "YES" ]
   then
      cat <<EOF

target_link_libraries( "\${EXECUTABLE_NAME}"
\${OS_SPECIFIC_LIBRARIES}
)
EOF
   else
      cat <<EOF
###

EOF
   fi

   cat <<EOF

install( TARGETS "${PROJECT_NAME}" DESTINATION "bin")
EOF
}


demo_version_h()
{
   log_entry "demo_version_h" "$@"

   cat <<EOF
/*
 *  version:  major, minor, patch
 */
#define ${PROJECT_UPCASE_IDENTIFIER}_VERSION  ((0 << 20) | (7 << 8) | 56)


static inline unsigned int   ${PROJECT_IDENTIFIER}_get_version_major( void)
{
   return( ${PROJECT_UPCASE_IDENTIFIER}_VERSION >> 20);
}


static inline unsigned int   ${PROJECT_IDENTIFIER}_get_version_minor( void)
{
   return( (${PROJECT_UPCASE_IDENTIFIER}_VERSION >> 8) & 0xFFF);
}


static inline unsigned int   ${PROJECT_IDENTIFIER}_get_version_patch( void)
{
   return( ${PROJECT_UPCASE_IDENTIFIER}_VERSION & 0xFF);
}

EOF
}


demo_file_h()
{
   log_entry "demo_file_h" "$@"

   cat <<EOF
#import <stdint.h>


uint32_t projectVersion( void);
EOF
}


demo_file_c()
{
   log_entry "demo_file_c" "$@"

   cat <<EOF
#import "Foo.h"
#import "version.h"


int   __${PROJECT_UPCASE_IDENTIFIER}_ranlib__;

uint32_t   projectVersion( void)
{
   return( ${PROJECT_UPCASE_IDENTIFIER}_VERSION);
}

EOF
}


demo_loader_h()
{
   log_entry "demo_loader_h" "$@"

   cat <<EOF
#import <${MULLE_C_HEADER_NAME}/${MULLE_C_HEADER_NAME}.h>


@interface MulleObjCLoader( ${PROJECT_NAME})
@end
EOF
}


demo_loader_c()
{
   log_entry "demo_loader_c" "$@"

   cat <<EOF
#import "MulleObjCLoader+${PROJECT_NAME}.h"


@implementation MulleObjCLoader( ${PROJECT_NAME})

+ (struct _culle_c_dependency *) dependencies
{
   static struct _culle_c_dependency   dependencies[] =
   {

#include "dependencies.inc"

      { MULLE_C_NO_CLASSID, MULLE_C_NO_CATEGORYID }
   };

   return( dependencies);
}

@end
EOF
}


demo_dependencies_inc()
{
   log_entry "demo_dependencies_inc" "$@"

   cat <<EOF
// this file will be replaced with generated contents after the first build
EOF
}


# must be .c
demo_standalone_c()
{
   log_entry "demo_standalone_c" "$@"

   cat <<EOF
int   __${PROJECT_IDENTIFIER}_unused__;

// that's all folks
EOF
}



demo_main_c()
{
   log_entry "demo_main_c" "$@"

   cat <<EOF
#include "Foo.h"
#include "version.h"


int  main( int argc, char *argv[])
{
   printf( "VfL Bochum %d\n", projectVersion());
   return( 0);
}
EOF
}


demo_common_files()
{
   log_entry "demo_common_files" "$@"

   local text

   if [ ! -e "README.md" -o "${FLAG_FORCE}" = "YES" ]
   then
      text="`emit_readme_md`"
      redirect_exekutor README.md echo "${text}"
   fi

   if [ ! -e "src/version.h" -o "${FLAG_FORCE}" = "YES" ]
   then
      mkdir_if_missing "src"
      text="`demo_version_h`"
      redirect_exekutor "src/version.h" echo "${text}"
   fi

   if [ ! -e "src/Foo.h" -o "${FLAG_FORCE}" = "YES" ]
   then
      mkdir_if_missing "src"
      text="`demo_file_h`"
      redirect_exekutor "src/Foo.h" echo "${text}"
   fi

   if [ ! -e "src/Foo.c" -o "${FLAG_FORCE}" = "YES" ]
   then
      mkdir_if_missing "src"
      text="`demo_file_c`"
      redirect_exekutor "src/Foo.c" echo "${text}"
   fi
}


demo_library_files()
{
   log_entry "demo_library_files" "$@"

   demo_common_files
}


demo_executable_files()
{
   log_entry "demo_executable_files" "$@"

   demo_common_files

   if [ ! -e "src/main.c" -o "${FLAG_FORCE}" = "YES" ]
   then
      mkdir_if_missing "src"
      redirect_exekutor "src/main.c" demo_main_c
   fi
}


__common_env()
{
   log_entry "__common_env" "$@"

   local directory

   directory="$PWD"
   if [ $# -ne 0 ]
   then
      directory="$1"
      shift
   fi

   mkdir_if_missing "${directory}"
   exekutor cd "${directory}" || fail "could not enter \"${directory}\""

   local dir_name

   dir_name="`basename -- "${directory}"`"

   PROJECT_NAME="${PROJECT_NAME:-${dir_name}}"
   PROJECT_IDENTIFIER="`echo "${PROJECT_NAME}" | tr '-' '_' | tr '[A-Z]' '[a-z]'`"
   PROJECT_UPCASE_IDENTIFIER="`echo "${PROJECT_IDENTIFIER}" | tr '[a-z]' '[A-Z]'`"
   UPCASE_MULLE_C_LIBRARY_IDENTIFIER="`echo "${UPCASE_MULLE_C_LIBRARY_NAME}" | tr '-' '_'`"
}


library_setup()
{
   log_entry "library_setup" "$@"

   __common_env "$@"

   if [ ! -f "CMakeLists.txt" -o "${FLAG_FORCE}" = "YES" ]
   then
      local text

      text="`
      (
         emit_cmakelists_common_header
         emit_cmakelists_library
         emit_cmakelists_common_footer
      )`"

      redirect_exekutor CMakeLists.txt echo "${text}"
   fi

   if [ ! -f "CMakeSourcesAndHeaders.txt" -o "${FLAG_FORCE}" = "YES" ]
   then
      redirect_exekutor CMakeSourcesAndHeaders.txt emit_sources_and_headers_library
   fi

   if [ ! -f "CMakeDependencies.txt" -o "${FLAG_FORCE}" = "YES" ]
   then
      redirect_exekutor CMakeDependencies.txt emit_dependencies_library
   fi

   if [ "${FLAG_OUTPUT_DEMO_FILES}" = "YES" ]
   then
      if [ ! -d src ]
      then
         demo_library_files
      fi
   fi
}


executable_setup()
{
   log_entry "executable_setup" "$@"

   __common_env "$@"

   if [ ! -f "CMakeLists.txt" -o "${FLAG_FORCE}" = "YES" ]
   then
      local text

      text="`
      (
         emit_cmakelists_common_header
         emit_cmakelists_executable
         emit_cmakelists_common_footer
      )`"

      redirect_exekutor CMakeLists.txt echo "${text}"
   fi

   if [ ! -f "CMakeSourcesAndHeaders.txt" -o "${FLAG_FORCE}" = "YES" ]
   then
      redirect_exekutor CMakeSourcesAndHeaders.txt emit_sources_and_headers_executable
   fi

   if [ "${FLAG_OUTPUT_DEMO_FILES}" = "YES" ]
   then
      demo_executable_files
   fi
}

main()
{
   # technical flags
   local MULLE_FLAG_DONT_DEFER="NO"
   local MULLE_FLAG_EXEKUTOR_DRY_RUN="NO"
   local MULLE_FLAG_FOLLOW_SYMLINKS="YES"
   local MULLE_FLAG_LOG_CACHE="NO"
   local MULLE_FLAG_LOG_DEBUG="NO"
   local MULLE_FLAG_LOG_EXEKUTOR="NO"
   local MULLE_FLAG_LOG_FLUFF="NO"
   local MULLE_FLAG_LOG_MERGE="NO"
   local MULLE_FLAG_LOG_SCRIPTS="NO"
   local MULLE_FLAG_LOG_SETTINGS="NO"
   local MULLE_FLAG_LOG_VERBOSE="NO"
   local MULLE_TRACE_PATHS_FLIP_X="NO"
   local MULLE_TRACE_POSTPONE="NO"
   local MULLE_TRACE_RESOLVER_FLIP_X="NO"
   local MULLE_TRACE_SETTINGS_FLIP_X="NO"

   local FLAG_FORCE="NO"
   local FILE_PREFIX="src/"
   local FLAG_OUTPUT_DEMO_FILES="YES"
   local OPTION_MULLE_C_DEVELOPER="NO"
   local OPTION_DYNAMIC_LINKED="NO"
   local OPTION_MIRROR_CLONES="YES"
   local OPTION_SEARCH_PATH

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h|--help)
            usage
         ;;

         -p|--project-name)
            shift
            [ $# -eq 0 ] && usage

            PROJECT_NAME="$1"
         ;;

         -f|--force)
            FLAG_FORCE="YES"
         ;;

         -s|--sparse)
            FILE_PREFIX="# src/"
            FLAG_OUTPUT_DEMO_FILES="NO"
         ;;

         --link-with-shared)
            OPTION_DYNAMIC_LINKED="YES"
         ;;

         --version)
            echo "${MULLE_C_DEVELOPER_VERSION}"
            exit 0
         ;;

         -*)
            usage
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   if [ "${MULLE_FLAG_EXEKUTOR_DRY_RUN}" = "YES" ]
   then
      FLAG_FORCE="YES"
   fi

   options_setup_trace "${MULLE_TRACE}"

   [ $# -eq 0 ] && usage

   local cmd="$1"
   shift

   case "${cmd}" in
      check)
         sanity_check
         exit $?
      ;;

      library)
         library_setup "$@"
      ;;

      executable)
         executable_setup "$@"
      ;;

      version)
         echo "${VERSION}"
         exit 0
      ;;

      *)
         fail "unknown command \"${cmd}\""
      ;;
   esac
}


_init()
{
   MULLE_BASHFUNCTIONS_LIBEXEC_DIR="`mulle-bashfunctions-env library-path 2> /dev/null`"
   [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ] && \
      echo "mulle-bashfunctions-env not installed" >&2 && \
      exit 1

   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-bashfunctions.sh" || exit 1
}


_init "$@"
main "$@"
