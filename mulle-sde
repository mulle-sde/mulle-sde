#! /usr/bin/env mulle-bash
# shellcheck shell=bash
#
#   Copyright (c) 2018 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
[ "${TRACE}" = 'YES' -o "${MULLE_SDE_TRACE:-}" = 'YES' ] && set -x && : "$0" "$@"
[ "${MULLE_SDE_DUMP_ENV:-}" = 'YES' ] && env | sort >&2


MULLE_EXECUTABLE_VERSION=3.5.0
MULLE_EXECUTABLE_BASHFUNCTIONS="6.2"

#
# Determine location of own libexec directory. Which is `src` in development
# and ../libexec when deployed. MULLE_EXECUTABLE needs to be defined for this.
#

if ! [ ${MULLE_SDE_LIBEXEC_DIR+x} ]
then
   r_get_libexec_dir "${MULLE_EXECUTABLE}" "mulle-sde" "mulle-sde-clean.sh"
   MULLE_SDE_LIBEXEC_DIR="${RVAL}"
fi

#
# This is the sde::main user interface to mulle-sde
# sorta like git
#
function sde::print_commands()
{
   local show_all="${1:-NO}"

   if [ -z "${MULLE_VIRTUAL_ROOT}" -a ! -d .mulle/etc/env ]
   then
      SHOWN_COMMANDS="\
   add            : create a source file from templates
   api            : show API documentation from dependencies
   extension      : manage language and buildtool extensions
   howto          : show list of development topics for more extensive help
   init           : create a new project
   install        : install a remote mulle-sde project, like make install
   show           : show available meta extensions"

      HIDDEN_COMMANDS="\
   init-and-enter : create a new project then immediately start a subshell
   commands       : list of all available commands (some undocumented)
   libexec-dir    : print path to mulle-sde libexec
   uname          : the simplified uname(1)"

   else
      SHOWN_COMMANDS="\
   add            : create a source file from templates
   api            : show API documentation from dependencies
   clean          : clean various parts of the project
   craft          : craft the project using mulle-craft
   craftinfo      : show build flags of dependencies
   definition     : change projects craft options like CFLAGS
   dependency     : manage third party components (like GitHub projects)
   editors        : run various GUI tools (needs node.js)
   environment    : manage environment variables (project settings)
   exec           : run a command in a subshell
   howto          : show list of development topics for more extensive help
   ignore         : block files from being crafted
   library        : manage second party (OS) libraries (like pthread)
   log            : show craft results
   list           : list project files (files matching patternfiles)
   reflect        : update project makefiles and sources
   run            : run executable product
   status         : show information about the current project state
   view           : give an overview over the project settings"

      HIDDEN_COMMANDS="\
   cd             : change directory to dependency,kitchen et al.
   commands       : list of all available commands (some undocumented)
   craftorder     : show craftorder of dependencies
   craftstatus    : show the craft status of the dependencies
   config         : show multiple sourcetree configurations
   donefile       : show contents of donefiles
   crun           : craft and run if project is an executable
   callback       : manage reflection callbacks
   env-identifier : get variable name "MULLE_UIOS" for a name like "MulleUIOS"
   export         : export a dependency or library as mulle-sde commands
   extension      : manage language and buildtool extensions
   fetch          : fetch the sourcetree
   headerorder    : show header includes for dependencies and libraries
   init           : create a new project
   json           : show dependencies and libraries as JSON
   linkorder      : show linkorder of dependencies and libraries
   match          : experiment with patternfiles
   monitor        : monitor project files, run reflect and craft
   patternfile    : manage patternfiles
   product        : location of main executable or library, heuristic
   project-dir    : print project root directory
   project        : rename a project and its files
   recraft        : craft everything anew (cleans tidy)
   retest         : retest using mulle-test
   searchpath     : show search path for build products
   source-dir     : print project source directory
   subproject     : manage local subprojects
   symbol         : list C and Objective-C symbols of the project
   task           : manage reflection tasks
   test           : run tests using mulle-test
   treestatus     : show the sourcetree status
   unveil         : produce sandbox CSV"
   fi

   printf "%s\n" "${SHOWN_COMMANDS}" | LC_ALL=C sort

   if [ "${show_all}" != 'NO' ]
   then
      printf "%s\n" "${HIDDEN_COMMANDS}" | LC_ALL=C sort
   fi
}


sde::print_flags()
{
   local verbose="${1:-NO}"

   local delm

   delm="          : "

   if [ "${verbose}" = 'YES' ]
   then
      echo "   -d <dir>       : change to dir before executing commands"
      echo "   -e             : bypass mulle-env check"
      echo "   -f             : force operation"
      echo "   -N             : do not search for enclosing environment"
   fi

      echo "   -DKEY=VALUE    : define one-time environment variable"

   if [ -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      echo "   --style <val>  : see \`mulle-env help\` for style description"
   fi

   options_technical_flags_usage "${delm}"
}


sde::do_usage()
{
   local verbose="${1:-NO}"

   cat <<EOF
Usage:
   ${MULLE_USAGE_NAME} [flags] [command] [options]

   The commandline IDE with the development cycle Edit -> Reflect -> Craft.

   * Edit     you use your preferred editors and file managers
   * Reflect  mulle-sde creates the necessary make files
   * Craft    mulle-sde builds the dependencies and the project

   Read the "De Re mulle-sde" guide:
      https://www.mulle-kybernetik.com/de-re-mulle-sde/book.html

   ⚠️  ${MULLE_USAGE_NAME} is AI and noob friendly! Use:
      \`${MULLE_USAGE_NAME} commands\` to see all commands with descriptions
      \`${MULLE_USAGE_NAME} <cmd> help\` for detailed help (if marked help: yes)
      \`${MULLE_USAGE_NAME} howto help\` for development topics

EOF
   if [ -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      cat <<EOF
   Start a project with \`mulle-sde init\` or enter an existing mulle-sde
   project with \`mulle-sde <directory>\`. Get a quick view over the
   project with \`mulle-sde view\` and \`mulle-sde files\`. Manage external
   dependencies or add files with \`mulle-sde add\`.
EOF
   else
      cat <<EOF
   Edit source files in '${PROJECT_SOURCE_DIR:-src}'. If you add, delete, rename or move
   source files run \`mulle-sde reflect\`. Use \`mulle-sde craft\` to craft your
   project. Add system libraries with \`mulle-sde library\` and other
   dependencies with \`mulle-sde dependency\`.
EOF
   fi

   cat <<EOF

Flags:
EOF
   sde::print_flags "${verbose}" | LC_ALL=C sort

   cat <<EOF

Commands:
EOF

   sde::print_commands "${verbose}" | LC_ALL=C sort

   if [ "${verbose}" = 'NO' ]
   then
      cat <<EOF
      (use mulle-sde -v help to show more flags and commands)
EOF
   fi

   cat <<EOF

   Options are command specific. Use ${MULLE_USAGE_NAME} <command> -h for help.
EOF

   exit 1
}


sde::usage()
{
   sde::do_usage "$@" >&2
   exit 1
}


sde::set_custom_define()
{
   log_entry "sde::set_custom_define" "$@"

   local keyvalue="$1"

   local key
   local value

   key="${keyvalue%%=*}"

   if [ -z "${key}" ]
   then
      key="${keyvalue}"
   else
      value="${keyvalue#*=}"
   fi

   if [ "${key}" != "`printf "%q" "${key}"`" ]
   then
      fail "Invalid Environment key \"${key}\""
   fi

   eval "export ${key}=${value}"

   log_fluff "Set environment variable \"${key}\" to '${value}'"
}


sde::set_custom_environment()
{
   log_entry "sde::set_custom_environment" "$@"

   local defines="$1"

   local i

   .foreachline i in ${defines}
   .do
      sde::set_custom_define "${i#-D}"
   .done
}


sde::r_determine_project_dir()
{
   local directory="$1"

   RVAL="`( cd "${directory:-$PWD}" && sde::run_mulle_env --search-nearest project-dir )`"
}


sde::is_test_directory()
{
   log_entry "sde::is_test_directory" "$@"

   local directory="$1"

   r_filepath_concat "$1" ".mulle/share/test"
   directory="${RVAL}"

   log_debug "directory: ${directory} (${PWD#"${MULLE_USER_PWD}/"})"

   rexekutor [ -d "${directory}" ]
}


#
# why is this important ?
#
# mulle-sde craft will generate static libraries, but we want dynamic ones for
# tests, to keep test exes small.
#
# mulle-sde test craft will set the preference to --dynamic and possibly do
# some other settings as well.
#
sde::assert_test_environment()
{
   log_entry "sde::assert_test_environment" "$@"

   local cmd="${1:-craft}"

   if [ "${FLAG_TEST_CHECK}" = 'NO' ]
   then
      return
   fi

   if [ "${MULLE_TEST_ENVIRONMENT:-}" = 'YES' ]
   then
      if sde::is_test_directory "$PWD"
      then
         log_fluff "In test environment as expected"
         return
      fi
      if [ "${MULLE_FLAG_MAGNUM_FORCE}" = 'YES' ]
      then
         return
      fi
      # For clean operations, just warn instead of failing
      if [ "${cmd}" = 'clean' ]
      then
         log_fluff "Not inside the test environment, but continuing with clean"
         return
      fi
      fail "Not inside the test environment. Have you initialized it yet ?!?"
   else
      if ! sde::is_test_directory "$PWD"
      then
         log_debug "Not in a test environment"
         return
      fi
      if [ "${MULLE_FLAG_MAGNUM_FORCE}" = 'YES' ]
      then
         return
      fi
      fail "Use ${C_RESET_BOLD}mulle-sde test $cmd${C_ERROR} instead"
   fi
}


sde::run_mulle_env()
{
   log_entry "sde::run_mulle_env" "$@"

   #
   # possibly wrap mulle-env call into a sandbox (like a lljail script)
   #
   if [ ! -z "${MULLE_SDE_SANDBOX}" ]
   then
      rexekutor "${MULLE_SDE_SANDBOX}" ${MULLE_SDE_SANDBOX_FLAGS} \
                     "${MULLE_ENV:-mulle-env}" \
                        ${MULLE_TECHNICAL_FLAGS:-} \
                        ${MULLE_ENV_FLAGS:-} \
                        ${MULLE_FWD_FLAGS:-} \
                        --defines "${MULLE_DEFINE_FLAGS:-}" \
                        "$@"
      return $?
   fi

   rexekutor "${MULLE_ENV:-mulle-env}" \
                  ${MULLE_TECHNICAL_FLAGS:-} \
                  ${MULLE_ENV_FLAGS:-} \
                  ${MULLE_FWD_FLAGS:-} \
                  --defines "${MULLE_DEFINE_FLAGS:-}" \
                  "$@"
}


#
# execute a native mulle-env command, this is not expected to bounce back to
# mulle-sde
#
sde::exec_mulle_env()
{
   log_entry "sde::exec_mulle_env" "$@"

   log_setting "MULLE_TECHNICAL_FLAGS : ${MULLE_TECHNICAL_FLAGS}"
   log_setting "MULLE_ENV_FLAGS       : ${MULLE_ENV_FLAGS}"
   log_setting "MULLE_FWD_FLAGS       : ${MULLE_FWD_FLAGS}"
   #
   # possibly wrap mulle-env call into a sandbox (like lljail)
   #
   if [ ! -z "${MULLE_SDE_SANDBOX}" ]
   then
      rexekutor exec "${MULLE_SDE_SANDBOX}" ${MULLE_SDE_SANDBOX_FLAGS} \
                        "${MULLE_ENV:-mulle-env}" \
                            ${MULLE_TECHNICAL_FLAGS:-} \
                            ${MULLE_ENV_FLAGS:-} \
                            ${MULLE_FWD_FLAGS:-} \
                            --defines "${MULLE_DEFINE_FLAGS:-}" \
                            "$@"
      return $?
   fi

   rexekutor exec "${MULLE_ENV:-mulle-env}" \
                       ${MULLE_TECHNICAL_FLAGS:-} \
                       ${MULLE_ENV_FLAGS:-} \
                       ${MULLE_FWD_FLAGS:-} \
                       --defines "${MULLE_DEFINE_FLAGS:-}" \
                       "$@"
}


sde::exec_command_in_subshell()
{
   log_entry "sde::exec_command_in_subshell" "$@"

   local dir_action="$1" ; shift

   local current

   current="`pwd -P`"

   if ! sde::r_determine_project_dir "${current}"
   then
      if [ -d ".mulle-sde" ]
      then
         fail "There is only an old mulle-sde project in (${current#"${MULLE_USER_PWD}/"}).
${C_INFO}It should be upgradable with:
${C_RESET_BOLD}   mulle-sde upgrade
${C_RESET_BOLD}   mulle-sde clean tidy"
      fi

      # for scripts fail silently here
      if [ "${MULLE_FLAG_LOG_TERSE}" = 'YES' ]
      then
         exit 1
      fi
      fail "There is no mulle-sde project in (${current#"${MULLE_USER_PWD}/"}).
${C_INFO}Create an initial empty one with:
${C_RESET_BOLD}   mulle-sde init"
   else 
      if [ "${current}" != "${RVAL}" ]
      then
         log_verbose "Project directory determined to be ${C_RESET_BOLD}${RVAL#${MULLE_USER_PWD}/}"
      fi
   fi

   if [ "${dir_action}" = 'CD' -a "${current}" != "${RVAL}" ]
   then
      [ -z "${MULLE_USER_PWD}" ] && _internal_fail "MULLE_USER_PWD not set"
      exekutor cd "${RVAL}" || exit 1
   fi

   # These flags are eventually passed to mulle-sde again, they aren't
   # picked up by MULLE_ENV
   #
   local flag
   local cmdline

   cmdline="${MULLE_EXECUTABLE}"

   shell_disable_glob # keep it
   for flag in ${MULLE_TECHNICAL_FLAGS:-} ${MULLE_FWD_FLAGS:-}
   do
      cmdline="${cmdline}
${flag}"
   done

   while [ $# -ne 0 ]
   do
      cmdline="${cmdline}
$1"
      shift
   done

   #
   # here we are just bouncing through mulle-env, we don't want
   # to pass -n, so mulle-env does nothing. Pushing MULLE_TECHNICAL_FLAGS
   # unfiltered isn't good. The technical flags will be part of the incoming
   # command line in "$@"
   #
   if [ ! -z "${MULLE_SDE_SANDBOX}" ]
   then
      MULLE_USAGE_NAME="mulle-sde" \
      rexekutor exec "${MULLE_SDE_SANDBOX}" ${MULLE_SDE_SANDBOX_FLAGS} \
                        "${MULLE_ENV:-mulle-env}" \
                           ${MULLE_ENV_FLAGS:-} \
                           ${MULLE_FWD_FLAGS:-} \
                           --defines "${MULLE_DEFINE_FLAGS:-}" \
                           -C "${cmdline}"
      return $?
   fi

   MULLE_USAGE_NAME="mulle-sde" \
      rexekutor exec "${MULLE_ENV:-mulle-env}" \
                        ${MULLE_ENV_FLAGS:-} \
                        ${MULLE_FWD_FLAGS:-} \
                        --defines "${MULLE_DEFINE_FLAGS:-}" \
                        -C "${cmdline}"
}


sde::cd_virtual_root()
{
   local cmd="$1"
   local subenvcheck="${2:-YES}"
   local subenvwarn="${3:-YES}"

   if [ "${subenvcheck}" = 'YES' ]
   then
      case "${MULLE_SHELL_MODE}" in
         *SUBENV*)
            fail "You can not run \`mulle-sde ${cmd}\` inside a sub-environment"
         ;;
      esac
   fi

   if [ -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      fail "To run ${MULLE_EXECUTABLE_NAME} outside of mulle-env, pass the outside of mulle-env flag"
   fi

   log_debug "MULLE_VIRTUAL_ROOT: ${MULLE_VIRTUAL_ROOT}"

   local physdir

   physdir="`pwd -P`"

   #
   # this check can hit us, if we get a linkorder request in cmake for example
   # but we don't really want to warn then. subenvwarn is a hack
   # to suppress this.
   #
   log_debug "PWD:                ${physdir}"

   if [ "${physdir}" != "${MULLE_VIRTUAL_ROOT}" ]
   then
      #
      # quick check that we are not passing a "mulle-env" boundary
      #
      if [ -d "${physdir}/.mulle/share/env" ]
      then
         if [ "${subenvwarn}" = 'YES' ]
         then
            _log_warning "${MULLE_EXECUTABLE} ${HACKY_ARGS}: \
warning \"${MULLE_VIRTUAL_ROOT}\" is virtual root, but we are in a subshell \
already ($physdir)"
         fi
      else
         physdir="${MULLE_VIRTUAL_ROOT}"
      fi
   fi

   # ensure that we are in physical
   if [ "${physdir}" != "${PWD}" ]
   then
      rexekutor cd "${physdir}" \
      || fail "could not enter physical virtual root (${MULLE_VIRTUAL_ROOT})"
   fi

   # set MULLE_VIRTUAL_ROOT to physical (can have changed above intermittently)
   MULLE_VIRTUAL_ROOT="${PWD}"
}


sde::cd_virtual_root_assert_mulle_sde()
{
   sde::cd_virtual_root "$@"

   if [ "${FLAG_OUTSIDE_ENV}" = "YES" ]
   then
      return
   fi

   [ ! -d "${MULLE_SDE_SHARE_DIR}" ] \
   && fail "There is no ${MULLE_SDE_SHARE_DIR} here"
}


sde::try_to_enter_or_download()
{
   local dst="$1"

   if [ $# -eq 1 ]
   then
      case "$1" in
         *://*)
            dst="`exekutor "${MULLE_FETCH:-mulle-fetch}" \
                              ${MULLE_TECHNICAL_FLAGS} \
                              ${MULLE_FETCH_FLAGS} \
                              convenient-fetch "$@"`" || exit 1
            if [ -d "${dst}/.mulle" ]
            then
               MULLE_USAGE_NAME="mulle-sde" \
               sde::exec_mulle_env "${dst}"
            fi

            # just warn, but quit anyway
            log_warning "\"${dst#"${MULLE_USER_PWD}/"}\" is not a mulle-sde project"
            exit 1
         ;;

         *)
            if [ -d "$1" ]
            then
               MULLE_USAGE_NAME="mulle-sde" \
                  sde::exec_mulle_env "$@"
            fi
         ;;
        esac
   fi

   log_error "Unknown command \"${cmd}\""
   sde::usage "${MULLE_TRACE}"
}


sde::is_non_environment_commandline()
{
   while [ $# -ne 0 ]
   do
      case "$1" in
         -h|--help|help)
            return 0
         ;;

         --)
            break
         ;;

      esac
      shift
   done

   return 1
}


sde::main()
{
   local FLAG_TEST_CHECK="${MULLE_SDE_TEST_CHECK:-YES}"
   local FLAG_OUTSIDE_ENV='NO'

   local defines

   #
   # simple option handling
   #
   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -h|--help|help)
            sde::usage "${MULLE_TRACE}"
         ;;

         -e|--environment-override)
            FLAG_OUTSIDE_ENV='YES'
         ;;

         --test-check)
            FLAG_TEST_CHECK='YES'
         ;;

         --no-test-check)
            FLAG_TEST_CHECK='NO'
         ;;

         -f|--force)
            MULLE_FLAG_MAGNUM_FORCE='YES'
            r_concat "${MULLE_FWD_FLAGS}" "$1"
            MULLE_FWD_FLAGS="${RVAL}"
         ;;

         -c|-C)
            sde::exec_mulle_env "$@"
         ;;
                 # this has never been used really so far
         --git-terminal-prompt)
            [ $# -eq 1 ] && fail "Missing argument to \"$1\""

            r_concat "${MULLE_FWD_FLAGS}" "$1"
            MULLE_FWD_FLAGS="${RVAL}"
            shift

            GIT_TERMINAL_PROMPT="$1"
            export GIT_TERMINAL_PROMPT

            r_concat "${MULLE_FWD_FLAGS}" "$1"
            MULLE_FWD_FLAGS="${RVAL}"
         ;;

         --style)
            [ $# -eq 1 ] && fail "Missing argument to \"$1\""

            # add --style
            r_concat "${MULLE_ENV_FLAGS}" "$1"
            MULLE_ENV_FLAGS="${RVAL}"
            shift

            # add --argument
            r_concat "${MULLE_ENV_FLAGS}" "$1"
            MULLE_ENV_FLAGS="${RVAL}"
            export MULLE_ENV_FLAGS
         ;;

         --version)
            printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
            exit 0
         ;;

         -N|--search-nearest|--no-search)  # --no-search is historic
            r_concat "${MULLE_ENV_FLAGS}" "--search-nearest"
            MULLE_ENV_FLAGS="${RVAL}"
            export MULLE_ENV_FLAGS
         ;;

         --search-as-is|--search-here|--search-none)  # --no-search is historic
            r_concat "${MULLE_ENV_FLAGS}" "$1"
            MULLE_ENV_FLAGS="${RVAL}"
            export MULLE_ENV_FLAGS
         ;;

         --list-flags)
            (
               echo "\
--environment-override
--force
--git-terminal-prompt
--no-search
--no-test-check
--style
--version"
               options_technical_flags --list-technical-flags
            ) | sort
            exit 0
         ;;

         -D*)
            r_add_line "${MULLE_DEFINE_FLAGS}" "$1"
            MULLE_DEFINE_FLAGS="${RVAL}"

            r_add_line "${defines}" "$1"
            defines="${RVAL}"
         ;;

         -d)
            [ $# -eq 1 ] && fail "Missing argument to \"$1\""
            shift

            exekutor cd "$1" || exit 1
         ;;

         -*)
            log_error "Unknown option \"$1\""
            sde::usage "${MULLE_TRACE:-}"
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE:-}" && set -x

   local cmd

   cmd="$1"

   # alias step
   case "${cmd}" in
      'vibecode')
         cmd='vibecoding'
      ;;

      'sweatcode')
         cmd='sweatcoding'
      ;;
   esac

   if [ "${FLAG_OUTSIDE_ENV}" = 'YES' ]
   then
      MULLE_VIRTUAL_ROOT="`pwd -P`"
      [ "${MULLE_VIRTUAL_ROOT}" = "/" ] && fail "MULLE_VIRTUAL_ROOT can't be /"
      export MULLE_VIRTUAL_ROOT
   else
      #
      # a "convenient" ? shortcut to do projects w/o having to enter
      # a subshell. Starts a subshell every time though....
      #

      if [ -z "${MULLE_VIRTUAL_ROOT:-}" ]
      then
         case "${cmd}" in
            # commands that do not need a subshell (immediately)
            add|api|bash-completion|commands|common-unames|env|environment|\
env-identifier|edit|ext|extension|get|init|init-and-enter|install|reinit|\
status|hostname|howto|remove|uname|show|version|libexec-dir|library-path|project-dir|\
retest|set|source-dir|steal|symlink|test|upgrade|username|source-tree|\
project-tree)
            ;;

            # commands where we want to start a subshell and these don't have
            # any help text
            editor|addiction-dir|craftorder-kitchen-dir|dependency-dir|\
kitchen-dir|tool-env|stash-dir|*-tree|*-open|todo)
               sde::exec_command_in_subshell 'CD' "$@"
            ;;

            #
            # commands that execute in the user PWD
            #
            run|exec|execute|debug)
               if ! sde::is_non_environment_commandline "$@"
               then
                  sde::exec_command_in_subshell 'STAY' "$@"
               fi
            ;;


            _install)
               # shellcheck source=src/mulle-sde-install.sh
               include "sde::install"

               shift
               sde::install::main "$@"
               return $?
            ;;

            enter)
               shift
               MULLE_USAGE_NAME="mulle-sde" \
                  sde::exec_mulle_env "$@"
            ;;

            #
            # commands that have a help text, we want to show this even
            # if there is no environment around
            #
            callback|clean|config|craft|craftinfo|craftorder|craftstatus|\
craft-status|definition|dep|dependency|doctor|donefile|export|\
fetch|file|files|filename|find|headerorder|ignore|json|library|\
linkorder|list|log|mark|match|migrate|monitor|move|\
patterncheck|patternenv|patternfile|patternfiles|\
product|project|protect|reflect|recraft|searchpath|sourcetree|\
subproject|style|\
sweatcoding|symbol|symbols|task|tool|treestatus|unmark|unprotect|update|\
lib|pat|sub|unveil|view|vibecoding)
               if ! sde::is_non_environment_commandline "$@"
               then
                  sde::exec_command_in_subshell 'CD' "$@"
               fi
            ;;


            "")
               # special treatment for empty, show sde::usage
               if ! MULLE_USAGE_NAME="mulle-sde" \
                     sde::exec_mulle_env -s
               then
                  log_warning "No mulle-sde project found"
                  sde::usage
               fi
               exit 0
            ;;

            *)
               sde::try_to_enter_or_download "$@"
            ;;
         esac
      else
         # commands where we cant be in the subshell
         case "${cmd}" in
            upgrade)
               fail "upgrade must run outside the subshell"
            ;;
         esac
      fi
   fi

   [ $# -ne 0 ] && shift

   #
   # think about having a second MULLE_VIRTUAL_ROOT so that the project can
   # be read only and we keep the bookkeeping somewhere on the outside
   #
   log_setting "MULLE_VIRTUAL_ROOT    = \"${MULLE_VIRTUAL_ROOT}\""
   log_setting "MULLE_TECHNICAL_FLAGS = \"${MULLE_TECHNICAL_FLAGS}\""

   if ! sde::is_non_environment_commandline "$@"
   then
      # get these variables via mulle-tool-env
      #
      # MULLE_SDE_VAR_DIR
      # MULLE_SDE_ETC_DIR
      # MULLE_SDE_SHARE_DIR
      #
      if ! eval `"${MULLE_ENV:-mulle-env}" --search-as-is mulle-tool-env sde`
      then
         if [ "${FLAG_OUTSIDE_ENV}" != "YES" ]
         then
            return 1
         fi
         # assume user knows what hes doing
      else
         if [ -z "${MULLE_SDE_VAR_DIR}" ]
         then
            if [ -z "`pwd -P`" ]
            then
               fail "The working directory ${PWD} has been deleted"
            else
               fail "Mysteriously failed to acquire tool environment"
            fi
         fi

         if [ ! -z "${defines:-}" ]
         then
            sde::set_custom_environment "${defines}"
         fi

         local hook
         local cmdidentifier
         local value

         # problem here is that cmdidentifier is not validate to be sane

         if [ "${BASH_VERSINFO[0]}" -ge 4 ]
         then
            cmdidentifier="${cmd^^}"
            cmdidentifier="${cmdidentifier//-/_}"

            hook="MULLE_SDE_${cmdidentifier}_PRELUDE"

            # run hook if environment variable is set
            r_shell_indirect_expand "${hook}"
            value="${RVAL}"

            if [ ! -z "${value}" ]
            then
               "${value}" >&2
            fi
         fi
      fi
   fi

   log_setting "MULLE_SDE_VAR_DIR     = \"${MULLE_SDE_VAR_DIR}\""
   log_setting "MULLE_SDE_ETC_DIR     = \"${MULLE_SDE_ETC_DIR}\""
   log_setting "MULLE_SDE_SHARE_DIR   = \"${MULLE_SDE_SHARE_DIR}\""
   log_setting "MULLE_VIBECODING      = ${MULLE_VIBECODING:-NO}"

   case "${cmd}" in
      *-open)
         case "${MULLE_UNAME}" in
            linux)
               if ! OPEN="${OPEN:-`command -v xdg-open`}"
               then
                  fail "Need \"xdg-open\" command in PATH"
               fi
            ;;

            macos)
               if ! OPEN="${OPEN:-`command -v open`}"
               then
                  fail "Need \"open\" command in PATH"
               fi
            ;;

            *)
               fail "Open is not supported on \"${MULLE_UNAME}\""
            ;;
         esac

         local directory

         directory="`rexekutor "${MULLE_SDE:-mulle-sde}" \
                                             ${MULLE_TECHNICAL_FLAGS} \
                                             "${cmd%-open}-dir" `"
         [ ! -d "${directory}" ] && fail "\"${directory}\" does not (yet) exist"

         rexekutor "${OPEN}" "${directory}"
      ;;

      *-tree)
         if ! TREE="${TREE:-`command -v tree`}"
         then
            fail "Need \"tree\" command in PATH"
         fi

         local directory

         directory="`rexekutor "${MULLE_SDE:-mulle-sde}" \
                                             ${MULLE_TECHNICAL_FLAGS} \
                                             "${cmd%-tree}-dir" `"
         [ ! -d "${directory}" ] && fail "\"${directory}\" does not (yet) exist"

         local treeflags case

         case "${cmd}" in
            kitchen-tree)
               treeflags=-a
            ;;
         esac
         rexekutor "${TREE}" ${treeflags} --noreport "$@" "${directory}"
      ;;

      'add')
         # shellcheck source=src/mulle-sde-add.sh
         include "sde::add"

         sde::add::main "$@"
      ;;

      'addiction-dir'|'craftorder-kitchen-dir'|'dependency-dir'|'kitchen-dir')
         rexekutor "${MULLE_CRAFT:-mulle-craft}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     "${cmd}"
      ;;

      'bash-completion')
         log_warning "bash completion no longer supported"
      ;;

      'callback'|'task')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            if [ "${PROJECT_TYPE}" = 'none' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
            then
               fail "PROJECT_TYPE is 'none', nothing to ${cmd}"
            fi
         fi

         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
            exekutor "${MULLE_MONITOR:-mulle-monitor}" \
                           ${MULLE_TECHNICAL_FLAGS} \
                        "${cmd}" \
                           "$@"
      ;;

      'clean')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'YES' 'NO'
            sde::assert_test_environment "${cmd}"
         fi

         # shellcheck source=src/mulle-sde-clean.sh
         include "sde::clean"

         sde::clean::main "$@"
      ;;

      'commands')
         cat <<EOF
add - create a source file from templates (help: yes)
addiction-dir - print path to addiction/dependency build directory (help: no)
api - show API documentation from dependencies (help: yes)
bash-completion - deprecated, bash completion no longer supported (help: no)
callback - manage reflection callbacks (help: yes)
clean - clean various parts of the project (help: yes)
commands - list of all available commands (some undocumented) (help: no)
common-unames - list supported platform names (help: yes)
config - show multiple sourcetree configurations (help: yes)
craft - craft the project using mulle-craft (help: yes)
craftinfo - show build flags of dependencies (help: yes)
craftinfos - alias for craftinfo (help: yes)
craftorder - show craftorder of dependencies (help: yes)
craftorders - alias for craftorder (help: yes)
craftstatus - show the craft status of the dependencies (help: yes)
craft-status - alias for craftstatus (help: yes)
crun - craft and run if project is an executable (help: yes)
debug - run executable product in debugger (help: yes)
def - alias for definition (help: yes)
definition - change projects craft options like CFLAGS (help: yes)
definitions - alias for definition (help: yes)
dep - alias for dependency (help: yes)
dependency - manage third party components (like GitHub projects) (help: yes)
dependency-dir - print path to dependency directory (help: no)
doctor - diagnose project issues (help: yes)
donefile - show contents of donefiles (help: yes)
donefiles - alias for donefile (help: yes)
edit - open project in editor (help: yes)
editor - alias for edit (help: yes)
enter - enter mulle-sde subshell environment (help: yes)
env - alias for environment (help: yes)
env-identifier - get variable name MULLE_UIOS for a name like MulleUIOS (help: yes)
environment - manage environment variables (project settings) (help: yes)
exec - run a command in a subshell (help: yes)
execute - alias for exec (help: yes)
export - export a dependency or library as mulle-sde commands (help: yes)
ext - alias for extension (help: yes)
extension - manage language and buildtool extensions (help: yes)
fetch - fetch the sourcetree (help: yes)
file - alias for files (help: yes)
files - alias for list (help: yes)
find - find files in project (help: yes)
get - get environment variable value (help: yes)
headerorder - show header includes for dependencies and libraries (help: yes)
hostname - print hostname (help: no)
howto - show list of development topics for more extensive help (help: yes)
ignore - block files from being crafted (help: yes)
init - create a new project (help: yes)
init-and-enter - create a new project then immediately start a subshell (help: yes)
install - install a remote mulle-sde project, like make install (help: yes)
json - show dependencies and libraries as JSON (help: yes)
kitchen-dir - print path to kitchen build directory (help: no)
lib - alias for library (help: yes)
libexec-dir - print path to mulle-sde libexec (help: no)
libraries - alias for library (help: yes)
library - manage second party (OS) libraries (like pthread) (help: yes)
library-path - show library search paths (help: yes)
linkorder - show linkorder of dependencies and libraries (help: yes)
list - list project files (files matching patternfiles) (help: yes)
log - show craft results (help: yes)
mark - mark files with attributes (help: yes)
match - experiment with patternfiles (help: yes)
migrate - migrate project to newer mulle-sde version (help: yes)
monitor - monitor project files, run reflect and craft (help: yes)
move - move/rename files in project (help: yes)
pat - alias for patternfile (help: yes)
patterncheck - check pattern matching (help: yes)
patternenv - show pattern environment variables (help: yes)
patternfile - manage patternfiles (help: yes)
patternfiles - alias for patternfile (help: yes)
filename - check if filename matches patterns (help: yes)
patternmatch - alias for match (help: yes)
product - location of main executable or library, heuristic (help: yes)
project - rename a project and its files (help: yes)
project-dir - print project root directory (help: no)
protect - protect files from deletion (help: yes)
recraft - craft everything anew (cleans tidy) (help: yes)
reflect - update project makefiles and sources (help: yes)
reinit - reinitialize project (help: yes)
remove - remove files from project (help: yes)
retest - retest using mulle-test (help: yes)
run - run executable product (help: yes)
searchpath - show search path for build products (help: yes)
set - set environment variable value (help: yes)
show - show available meta extensions (help: yes)
source-dir - print project source directory (help: no)
sourcetree - alias for config (help: yes)
stash-dir - print path to stash directory (help: no)
status - show information about the current project state (help: yes)
steal - steal/copy files from another project (help: yes)
style - show or set project style (help: yes)
sub - alias for subproject (help: yes)
subproject - manage local subprojects (help: yes)
subprojects - alias for subproject (help: yes)
sweatcoding - enable sweat coding mode (help: yes)
symbol - list C and Objective-C symbols of the project (help: yes)
symbols - alias for symbol (help: yes)
symlink - create symlinks in project (help: yes)
task - manage reflection tasks (help: yes)
test - run tests using mulle-test (help: yes)
todo - show TODO items in project (help: yes)
tool - manage build tools (help: yes)
tool-env - show tool environment variables (help: yes)
treestatus - show the sourcetree status (help: yes)
uname - the simplified uname(1) (help: no)
unprotect - unprotect files (help: yes)
unveil - produce sandbox CSV (help: yes)
update - update dependencies (help: yes)
upgrade - upgrade mulle-sde project (help: yes)
username - print username (help: no)
version - show mulle-sde version (help: no)
vibecoding - enable vibe coding mode (help: yes)
view - give an overview over the project settings (help: yes)
EOF
         exit 0
      ;;

      'common-unames')
         rexekutor mulle-bashfunctions common-unames
      ;;

      'config'|'sourcetree')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            # sde::assert_test_environment "${cmd}"
         fi
         # shellcheck source=src/mulle-sde-config.sh
         include "sde::config"

         sde::config::main "$@"
      ;;

      'craft'|'recraft')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            sde::assert_test_environment "${cmd}"
         fi

         # shellcheck source=src/mulle-sde-craft.sh
         include "sde::craft"

         if [ "${cmd}" = 'recraft' ]
         then
            sde::craft::main --tidy "$@"
         else
            sde::craft::main "$@"
         fi
      ;;

      'craftinfo'|'craftinfos')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            sde::assert_test_environment "${cmd}"
         fi

         # shellcheck source=src/mulle-sde-craftinfo.sh
         include "sde::craftinfo"

         sde::craftinfo::main "$@"
      ;;

      'craftorder'|'craftorders')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            sde::assert_test_environment "${cmd}"
         fi


         # shellcheck source=src/mulle-sde-craftorder.sh
         include "sde::craftorder"

         sde::craftorder::main "$@"
      ;;

      'craftstatus'|'craft-status')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            sde::assert_test_environment "${cmd}"
         fi

         # shellcheck source=src/mulle-sde-craft.sh
         include "sde::craft"

         sde::craft::craftstatus_main "$@"
      ;;

      'crun')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            sde::assert_test_environment "${cmd}"
         fi

         # shellcheck source=src/mulle-sde-craft.sh
         include "sde::craft"

         sde::craft::main --run "$@"
      ;;

      'debug')
         # shellcheck source=src/mulle-sde-debug.sh
         include "sde::debug"

         sde::debug::main "$@"
      ;;

      'definition'|'definitions'|'def')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"

            if [ "${PROJECT_TYPE}" = 'none' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
            then
               fail "PROJECT_TYPE is 'none', nothing to define"
            fi
         fi

         # shellcheck source=src/mulle-sde-definition.sh
         include "sde::definition"

         sde::definition::main "$@"
      ;;

      'dependency'|'dep')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi

         # shellcheck source=src/mulle-sde-dependency.sh
         include "sde::dependency"

         sde::dependency::main "$@"
      ;;


      'donefile'|'donefiles')
         exekutor "${MULLE_CRAFT:-mulle-craft}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     "${cmd}" "$@"
      ;;

      'edit')
         [ "${MULLE_VIBECODING}" = 'YES' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ] && fail "${cmd} not available with ${C_RESET_BOLD}vibecoding${C_ERROR} enabled"
         # shellcheck source=src/mulle-sde-edit.sh
         include "sde::edit"

         sde::edit::main "$@"
      ;;

      'editor')
         [ "${MULLE_VIBECODING}" = 'YES' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ] && fail "${cmd} not available with ${C_RESET_BOLD}vibecoding${C_ERROR} enabled"

         local editors
         local row

         editors="\
definition  - set compiler and linker flags and more
environment - view and set environment of the mulle-sde subshell
monitor     - manage the reflection mechanism
patternfile - matching and categorizing project files
sourcetree  - dependencies and libraries
tool        - available binaries in mulle-sde subshell"
         rexekutor mudo -f mulle-menu --title "Choose mulle-sde topic:" \
                                      --final-title '' \
                                      --options "${editors}"
         row=$?

         r_line_at_index "${editors}" $row
         [ -z "${RVAL}" ] && return 1

         local executable
         local executable_name

         executable_name="mulle-${RVAL%% *}-editor"
         if executable= $(mudo which "${executable_name}")
         then
            exekutor mudo -f "${executable}"
            return $?
         fi
         exekutor mudo -f npx mulle-sde/mulle-${RVAL%% *}-editor
      ;;

      'enter')
         fail "Command must be run from outside of the current environment."
      ;;

      'environment'|'env')
         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
            sde::exec_mulle_env -N \
                                "environment" \
                                "$@"
#         if ! sde::is_non_environment_commandline "$@"
#         then
#            sde::cd_virtual_root "environment" 'NO'
#         fi
#
#         # shellcheck source=src/mulle-sde-environment.sh
#         . "${MULLE_SDE_LIBEXEC_DIR}/mulle-sde-environment.sh" || exit 1
#
#         sde::environment::main "$@"
      ;;

      'env-identifier')
         include "case"

         [ -z "$1" ] && fail "Specify desired project name for env-identifier"
         r_smart_file_upcase_identifier "$1"

         rexekutor printf "%s\n" "${RVAL}"
      ;;

      'exec'|'execute')
         local quote
         local args
         local arg

         # why is it important that we eval here ? We want to use
         # local environment variables
         quote="'"
         args=""
         for arg in "$@"
         do
            arg="${arg//${quote}/${quote}\"${quote}\"${quote}}"
            args="${args} '${arg}'"
         done

         unset quote
         unset arg

         eval_exekutor "${args}"
      ;;

      'export')
         # shellcheck source=src/mulle-sde-export.sh
         include "sde::export"

         sde::export::main "$@"
      ;;

      'extension'|'ext')
         # shellcheck source=src/mulle-sde-extension.sh
         include "sde::extension"

         sde::extension::main "$@"
      ;;

      'fetch')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"
         fi
         # shellcheck source=src/mulle-sde-fetch.sh
         include "sde::fetch"

         sde::fetch::main "$@"
      ;;

      'file'|'files')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi
         # shellcheck source=src/mulle-sde-list.sh
         include "sde::list"

         sde::list::main --files "$@"
      ;;

      'get'|'set')
         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
            sde::exec_mulle_env -N \
                                "environment" \
                                "${cmd}" "$@"
         exekutor "${MULLE_ENV:-mulle-env}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     "${cmd}" "$@"
      ;;

      'headerorder')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO' 'NO'

            sde::assert_test_environment "${cmd}"
         fi
         # shellcheck source=src/mulle-sde-headerorder.sh
         include "sde::headerorder"

         sde::headerorder::main "$@"
      ;;

      'hostname')
         rexekutor printf "%s\n" "${MULLE_HOSTNAME}"
      ;;

      'howto')
         # shellcheck source=src/mulle-sde-howto.sh
         include "sde::howto"

         sde::howto::main "$@"
      ;;

      'api')
         # shellcheck source=src/mulle-sde-api.sh
         include "sde::api"

         sde::api::main "$@"
      ;;

      'ignore')
         # shellcheck source=src/mulle-sde-ignore.sh
         include "sde::ignore"

         sde::ignore::main "$@"
      ;;

      'init')
         # shellcheck source=src/mulle-sde-init.sh
         include "sde::init"

         unset MULLE_SDE_VAR_DIR
         unset MULLE_SDE_ETC_DIR
         unset MULLE_SDE_SHARE_DIR

         sde::init::main "$@"
      ;;

      'init-and-enter')
         # shellcheck source=src/mulle-sde-init.sh
         include "sde::init"

         # interactive shell, dont set sde::usage
         sde::init::main --no-blurb "$@" && sde::exec_mulle_env
      ;;

      'install')
         # invoke ourselves with a clean environment so that we
         # don't accidentally inherit something from the current
         # environment. If you use -n, it won't work. This is not a "bounce"
         # though
         sde::exec_mulle_env invoke "${MULLE_EXECUTABLE}" \
                               ${MULLE_TECHNICAL_FLAGS} \
                               ${MULLE_FWD_FLAGS} \
                           _install \
                                 "$@"
         return $?
      ;;

      'json')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi

         exekutor "${MULLE_SOURCETREE:-mulle-sourcetree}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     "json" "$@"
      ;;

      'library'|'libraries'|'lib')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi
         # shellcheck source=src/mulle-sde-library.sh
         include "sde::library"

         sde::library::main "$@"
      ;;

      'libexec-dir'|'library-path')
         exekutor printf "%s\n" "${MULLE_SDE_LIBEXEC_DIR}"
      ;;

      'linkorder')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO' 'NO'

            sde::assert_test_environment "${cmd}"
         fi
         # shellcheck source=src/mulle-sde-linkorder.sh
         include "sde::linkorder"

         sde::linkorder::main "$@"
      ;;

      'list')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi
         # shellcheck source=src/mulle-sde-list.sh
         include "sde::list"

         sde::list::main "$@"
      ;;

      'log')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO' 'NO'

            sde::assert_test_environment "${cmd}"
         fi

         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
            exekutor "${MULLE_CRAFT:-mulle-craft}" \
                           ${MULLE_TECHNICAL_FLAGS} \
                        log \
                           "$@"
      ;;

      'match')
         # shellcheck source=src/mulle-sde-match.sh
         include "sde::match"

         sde::match::main "$@"
      ;;

      'move')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi

         # shellcheck source=src/mulle-sde-dependency.sh
         include "sde::dependency"

         sde::dependency::main "${cmd}" "$@"
      ;;

      # convenient shortcuts
      'mark'|'unmark')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'

         fi
         # shellcheck source=src/mulle-sde-dependency.sh
         include "sde::dependency"

         sde::dependency::main "${cmd}" "$@"
      ;;


      'migrate')
         _log_warning "Command only to be used for development of mulle-sde"

         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi
         # shellcheck source=src/mulle-sde-migrate.sh
         include "sde::migrate"

         sde::migrate::main "$@"
      ;;

      'monitor')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root "${cmd}"

            if [ "${PROJECT_TYPE}" = 'none' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
            then
               fail "PROJECT_TYPE is 'none', nothing to ${cmd}"
            fi
         fi

         # shellcheck source=src/mulle-sde-monitor.sh
         include "sde::monitor"

         sde::monitor::main "$@"
      ;;

      'patterncheck'|'patternenv'|'patternfile'|'pat'|'patternfiles'|'filename'|'patternmatch')
         cmd="${cmd//patternfiles/patternfile}"

         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root "${cmd}" 'NO'

            if [ "${PROJECT_TYPE}" = 'none' -a "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
            then
               fail "PROJECT_TYPE is 'none', nothing to ${cmd}"
            fi
         fi

         # shellcheck source=src/mulle-sde-patternfile.sh
         include "sde::patternfile"

         sde::patternfile::main "${cmd}" "$@"
      ;;

      'product')
         # shellcheck source=src/mulle-sde-product.sh
         include "sde::product"

         sde::product::main "$@"
      ;;

      'project')
         # shellcheck source=src/mulle-sde-project.sh
         include "sde::project"

         sde::project::main "$@"
      ;;

      'project-dir')
         if ! sde::r_determine_project_dir "${PWD}"
         then
            return 1
         fi
         printf "%s\n" "${RVAL}"
      ;;

      'protect')
         # shellcheck source=src/mulle-sde-init.sh
         include "sde::init"

         sde::init::protect_unprotect "Protect" "a-w"
      ;;

      'reflect'|'update')
         if ! sde::is_non_environment_commandline "$@"
         then
            # must allow NO for subenv updates
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'
         fi
         # shellcheck source=src/mulle-sde-reflect.sh
         include "sde::reflect"

         sde::reflect::main "$@"
      ;;

      #
      # reinit is used to change the project variables and then reinstall
      # project files with --allow-project to get proper identifiers in
      # your files
      #
      'reinit')
         if [ "${MULLE_FLAG_MAGNUM_FORCE}" != 'YES' ]
         then
            log_error "You must run ${C_RESET_BOLD}reinit${C_ERROR} with the -f flag, as it is destructive!"
#
# reinit -f clobbers! so demo and project are off by default
#
            log_info "  Additionally specify option --allow-project if you want to reinit project files"
            log_info "  Additionally specify option --allow-demo if you want to reinit demo files"
            exit 1
         fi

         # shellcheck source=src/mulle-sde-init.sh
         include "sde::init"

         sde::init::main --reinit "$@"
      ;;

      'remove')
         # shellcheck source=src/mulle-sde-remove.sh
         include "sde::remove"

         sde::remove::main "$@"
      ;;

      'run')
         # shellcheck source=src/mulle-sde-run.sh
         include "sde::run"

         sde::run::main "$@"
      ;;

      # used by mulle-test
      'searchpath')
         exekutor "${MULLE_CRAFT:-mulle-craft}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     searchpath "$@"
      ;;

      'show')
         # shellcheck source=src/mulle-sde-extension.sh
         include "sde::extension"

         if [ $# -ne 0 ]
         then
            sde::extension::main show "$@"
         else
            sde::extension::main show meta
         fi
      ;;

      'source-dir')
         local directory
         local subdir

         if ! sde::r_determine_project_dir "${PWD}"
         then
            return 1
         fi

         directory="${RVAL}"
         subdir="`sde::run_mulle_env environment get PROJECT_SOURCE_DIR`"

         r_filepath_concat "${directory}" "${subdir}"
         printf "%s\n" "${RVAL}"
      ;;

      'stash-dir')
         exekutor "${MULLE_SOURCETREE:-mulle-sourcetree}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     stash-dir
      ;;

      'status'|'doctor')
         # shellcheck source=src/mulle-sde-status.sh
         include "sde::status"

         sde::status::main "$@"
      ;;

      'steal')
         # shellcheck source=src/mulle-sde-steal.sh
         include "sde::steal"

         sde::steal::main "$@"
      ;;

      'symbol'|'symbols')
         # shellcheck source=src/mulle-sde-symbol.sh
         include "sde::symbol"

         sde::symbol::main "$@"
      ;;

      'style')
         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
           sde::exec_mulle_env -N "${cmd}" "$@"
      ;;

      'subproject'|'subprojects'|'sub')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}" 'NO'

            if [ "${PROJECT_TYPE}" = 'none' ]
            then
               fail "PROJECT_TYPE is 'none', no subprojects are possible"
            fi
         fi

         # shellcheck source=src/mulle-sde-subproject.sh
         include "sde::subproject"

         sde::subproject::main "$@"
      ;;

      'symlink')
         # shellcheck source=src/mulle-sde-product.sh
         include "sde::product"

         sde::product::symlink_main "$@"
      ;;

      'test'|'retest')
         if ! sde::is_non_environment_commandline "$@"
         then
            if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
            then
               rexekutor cd "${MULLE_VIRTUAL_ROOT}" \
               || fail "MULLE_VIRTUAL_ROOT \"${MULLE_VIRTUAL_ROOT}\" is missing"
            fi
         fi

         # shellcheck source=src/mulle-sde-test.sh
         include "sde::test"

         if [ "${cmd}" = 'retest' ]
         then
            set -- retest "$@"
         fi
         sde::test::main "$@"
      ;;

      'todo')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root "${cmd}"
         fi
         exekutor "${MULLE_TODO:-mulle-todo}" \
                        ${MULLE_TECHNICAL_FLAGS} \
                     "$@"
      ;;

      'tool')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root "${cmd}"
         fi
         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
           sde::exec_mulle_env -N "${cmd}" "$@"
      ;;

      'tool-env')
         (
            exekutor "${MULLE_CRAFT:-mulle-craft}" \
                           ${MULLE_TECHNICAL_FLAGS} \
                        "tool-env"
            exekutor "${MULLE_SOURCETREE:-mulle-sourcetree}" \
                           ${MULLE_TECHNICAL_FLAGS} \
                        "tool-env"
         ) | sort
      ;;

      'treestatus')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root_assert_mulle_sde "${cmd}"
         fi
         MULLE_USAGE_NAME="${MULLE_USAGE_NAME}" \
            exekutor "${MULLE_SOURCETREE:-mulle-sourcetree}" \
                           --virtual-root \
                           ${MULLE_TECHNICAL_FLAGS} \
                        status \
                           "$@"
      ;;

      'uname')
         rexekutor printf "%s\n" "${MULLE_UNAME}"
      ;;

      'unprotect')
         # shellcheck source=src/mulle-sde-init.sh
         include "sde::init"

         sde::init::protect_unprotect "Unprotect" "ug+w"
      ;;

      'unveil')
         if ! sde::is_non_environment_commandline "$@"
         then
            sde::cd_virtual_root "environment" 'NO'
         fi

         # shellcheck source=src/mulle-sde-unveil.sh
         include "sde::unveil"

         sde::unveil::main "$@"
      ;;

      'upgrade')
         # shellcheck source=src/mulle-sde-upgrade.sh
         include "sde::upgrade"

         sde::upgrade::main "$@"
      ;;

      'username')
         rexekutor printf "%s\n" "${MULLE_USERNAME}"
      ;;

      'version')
         rexekutor printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
         return 0
      ;;

      'vibecoding'|'sweatcoding')
         # shellcheck source=src/mulle-sde-vibecoding.sh
         include "sde::vibecoding"

         sde::vibecoding::main "${cmd}" "$@"
      ;;

      'view')
         log_info "${C_BR_BLUE}${C_BOLD}Environment"
         mulle-sde -s env list --output-eval \
         | GREP_COLOR=none grep -E '^MULLE_SOURCETREE_CONFIG|^MULLE_CRAFT_|FLAGS=' \
         | sed -e 's/^/   /'
         echo
         echo
         log_info "${C_BR_BLUE}${C_BOLD}Definition"
         mulle-sde definition
         echo
         echo
         log_info "${C_BR_BLUE}${C_BOLD}Dependency"
         mulle-sde dependency list --columnar -- -f "%a\n" --no-output-header \
         | sort \
         | sed -e 's/^/   /'
         echo
         echo
         log_info "${C_BR_BLUE}${C_BOLD}Library"
         mulle-sde library list -- -f "%a\n" --no-output-header \
         | sort \
         | sed -e 's/^/   /'
         echo
         echo
         log_info "${C_BR_BLUE}${C_BOLD}Craftinfo"
         mulle-sde craftinfo
         echo
      ;;


      '')
         log_warning "You are already in a virtual environment ($MULLE_VIRTUAL_ROOT)"
      ;;

      *)
         if [ -d "${cmd}" ]
         then
            fail "To enter a different mulle-sde environment, you must first \
${C_RESET_BOLD}exit${C_ERROR} the current environment."
         fi
         log_error "Unknown command \"${cmd}\""
         sde::usage "${MULLE_TRACE}"
      ;;
   esac

   rval=$?
   if [ ! -z "${cmdidentifier}" ]
   then
      if [ $rval -eq 0 ]
      then
         hook="MULLE_SDE_${cmdidentifier}_OK"
      else
         hook="MULLE_SDE_${cmdidentifier}_FAIL"
      fi

      # run hook if environment variable is set
      eval "[ ! -z \"\${${hook}}\" ] && eval \"\${${hook}}\"" >&2
   fi

   return $rval
}

HACKY_ARGS="$*"
call_with_flags "sde::main" "${MULLE_SDE_FLAGS:-}" "$@"
